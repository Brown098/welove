<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>订婚宴</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #8b0000 0%, #5a0000 100%);
            position: relative;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            height: 100vh;
            perspective: 1000px;
        }

        .container {
            position: relative;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ffd700;
            text-align: center;
            z-index: 2;
            padding: 20px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 4.5em;
            margin: 5px 0;
            letter-spacing: 3px;
            font-weight: 700;
            animation: pulse 3s infinite;
        }

        .date {
            font-size: 2.2em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .lunar-date {
            font-size: 1.7em;
            margin-bottom: 30px;
            font-weight: 300;
            opacity: 0.9;
        }

        .message {
            font-size: 1.4em;
            margin-bottom: 20px;
            max-width: 80%;
            line-height: 1.6;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px 30px;
            border-radius: 50px;
            backdrop-filter: blur(5px);
        }

        .couple-names {
            font-size: 2.2em;
            margin-top: 10px;
            font-family: 'Brush Script MT', cursive;
            color: #ffec8b;
        }

        .fireworks {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .petals {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        
        .petal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, transparent 60%, rgba(139, 0, 0, 0.8) 100%);
            z-index: 1;
            pointer-events: none;
        }

        .heart {
            position: absolute;
            color: rgba(255, 215, 0, 0.2);
            font-size: 24px;
            animation: float 6s infinite ease-in-out;
            z-index: 0;
        }

        /* 音乐控制按钮样式 */
        .music-control {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 10;
            backdrop-filter: blur(5px);
            border: 2px solid rgba(255, 215, 0, 0.5);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .music-control:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.2);
        }

        .music-icon {
            color: #ffd700;
            font-size: 28px;
            transition: all 0.3s ease;
        }

        .music-control.paused .music-icon {
            transform: rotate(30deg);
        }

        /* 音频元素隐藏 */
        #background-music {
            display: none;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.03); }
            100% { transform: scale(1); }
        }
        
        @keyframes float {
            0% { transform: translateY(0) rotate(0deg); opacity: 0; }
            10% { opacity: 0.8; }
            90% { opacity: 0.8; }
            100% { transform: translateY(-100vh) rotate(360deg); opacity: 0; }
        }

        /* 响应式调整 */
        @media (max-width: 768px) {
            h1 {
                font-size: 3em;
            }
            
   .lunar-date {
    font-size: 1.7em;
    margin-bottom: 50px; /* 增大与下一行的间距 */
    font-weight: 300;
    opacity: 0.9;
}

.message {
    font-size: 1.4em;
    margin-bottom: 40px; /* 增大与下一行的间距 */
    max-width: 80%;
    line-height: 1.6;
    background: rgba(0, 0, 0, 0.2);
    padding: 15px 30px;
    border-radius: 50px;
    backdrop-filter: blur(5px);
}

.couple-names {
    font-size: 2.2em;
    margin-top: 10px;
    font-family: 'Brush Script MT', cursive;
    color: #ffec8b;
}
            
            .music-control {
                width: 50px;
                height: 50px;
                bottom: 20px;
                right: 20px;
            }
            
            .music-icon {
                font-size: 24px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Happy engagement</h1>
        <h1>订婚宴</h1>
        <div class="date">2025.8.2</div>
        <div class="couple-names">韦龙怡 & 张小芳</div>
        <div class="lunar-date">农历乙巳年闰六月初九</div>
        <div class="message">感谢您的到来，见证我们人生中最重要的时刻</div>
    </div>
    
    <canvas class="fireworks"></canvas>
    <canvas class="petals"></canvas>
    <div class="petal-overlay"></div>
    
    <!-- Floating hearts -->
    <div class="heart" style="left: 10%; top: 90%; animation-delay: 0s;">❤</div>
    <div class="heart" style="left: 20%; top: 85%; animation-delay: 1s;">❤</div>
    <div class="heart" style="left: 30%; top: 95%; animation-delay: 2s;">❤</div>
    <div class="heart" style="left: 40%; top: 90%; animation-delay: 3s;">❤</div>
    <div class="heart" style="left: 50%; top: 85%; animation-delay: 4s;">❤</div>
    <div class="heart" style="left: 60%; top: 95%; animation-delay: 5s;">❤</div>
    <div class="heart" style="left: 70%; top: 90%; animation-delay: 0.5s;">❤</div>
    <div class="heart" style="left: 80%; top: 85%; animation-delay: 1.5s;">❤</div>
    <div class="heart" style="left: 90%; top: 95%; animation-delay: 2.5s;">❤</div>

    <!-- 背景音乐元素 -->
    <audio id="background-music" loop>
        <!-- 请将下面的音频路径替换为您自己的背景音乐文件 -->
        <source src="wedding.mp3" type="audio/mpeg">
        <!-- 可以添加备用格式 -->
        <source src="engagement-music.ogg" type="audio/ogg">
    </audio>

    <!-- 音乐控制按钮 -->
    <div class="music-control" id="music-control">
        <div class="music-icon">♫</div>
    </div>

    <script>
        // 音乐控制功能
        const musicControl = document.getElementById('music-control');
        const backgroundMusic = document.getElementById('background-music');
        let isPlaying = false;

        // 尝试播放音乐（处理浏览器自动播放限制）
        function tryPlayMusic() {
            backgroundMusic.play().then(() => {
                isPlaying = true;
                musicControl.classList.remove('paused');
            }).catch(error => {
                console.log('音乐播放需要用户交互:', error);
                isPlaying = false;
                musicControl.classList.add('paused');
            });
        }

        // 初始尝试播放
        tryPlayMusic();

        // 点击控制音乐播放/暂停
        musicControl.addEventListener('click', () => {
            if (isPlaying) {
                backgroundMusic.pause();
                musicControl.classList.add('paused');
            } else {
                backgroundMusic.play();
                musicControl.classList.remove('paused');
            }
            isPlaying = !isPlaying;
        });

        // 监听用户交互，一旦有点击就尝试播放音乐（解决自动播放限制）
        document.addEventListener('click', () => {
            if (!isPlaying) {
                tryPlayMusic();
            }
        }, { once: true });

        // 烟花效果代码
        const canvas = document.querySelector('.fireworks');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        class Particle {
            constructor(x, y, color, speedX, speedY) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.speedX = speedX;
                this.speedY = speedY;
                this.gravity = 0.1;
                this.alpha = 1;
                this.fade = 0.01;
                this.size = Math.random() * 3 + 1;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += this.gravity;
                this.alpha -= this.fade;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.restore();
            }
        }

        class Firework {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = canvas.height;
                this.speedY = Math.random() * -5 - 5;
                this.speedX = Math.random() * 4 - 2;
                this.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
                this.particles = [];
                this.exploded = false;
                this.size = Math.random() * 3 + 2;
            }

            update() {
                if (!this.exploded) {
                    this.x += this.speedX;
                    this.y += this.speedY;
                    this.speedY += 0.1;

                    if (this.speedY >= 0) {
                        this.explode();
                    }
                } else {
                    for (let i = this.particles.length - 1; i >= 0; i--) {
                        this.particles[i].update();
                        this.particles[i].draw();

                        if (this.particles[i].alpha <= 0) {
                            this.particles.splice(i, 1);
                        }
                    }
                }
            }

            draw() {
                if (!this.exploded) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
            }

            explode() {
                this.exploded = true;
                const particleCount = 80 + Math.random() * 50;
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 5 + 2;
                    const speedX = Math.cos(angle) * speed;
                    const speedY = Math.sin(angle) * speed;
                    this.particles.push(new Particle(this.x, this.y, this.color, speedX, speedY));
                }
            }
        }

        const fireworks = [];

        function animateFireworks() {
            ctx.fillStyle = 'rgba(139, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (Math.random() > 0.93) {
                fireworks.push(new Firework());
            }

            for (let i = fireworks.length - 1; i >= 0; i--) {
                fireworks[i].update();
                fireworks[i].draw();

                if (fireworks[i].exploded && fireworks[i].particles.length === 0) {
                    fireworks.splice(i, 1);
                }
            }

            requestAnimationFrame(animateFireworks);
        }

        animateFireworks();

        // 花瓣效果代码
        const petalsCanvas = document.querySelector('.petals');
        const petalsCtx = petalsCanvas.getContext('2d');

        function resizePetalsCanvas() {
            petalsCanvas.width = window.innerWidth;
            petalsCanvas.height = window.innerHeight;
        }

        resizePetalsCanvas();
        window.addEventListener('resize', resizePetalsCanvas);

        // 花瓣颜色
        const petalColors = [
            '#FFC0CB', '#FFB6C1', '#FF69B4', '#FF1493', '#DB7093', 
            '#FFA07A', '#FF7F50', '#FF6347', '#FFD700', '#FFEC8B',
            '#FFA500', '#FF8C00', '#F0E68C', '#E6E6FA', '#D8BFD8'
        ];

        // 花瓣形状定义
        const petalShapes = [
            // 简单花瓣
            (ctx, size) => {
                ctx.beginPath();
                ctx.ellipse(0, 0, size * 0.8, size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
            },
            
            // 心形花瓣
            (ctx, size) => {
                ctx.beginPath();
                ctx.moveTo(0, -size * 0.5);
                ctx.bezierCurveTo(
                    size * 0.7, -size * 0.5,
                    size * 0.7, size * 0.3,
                    0, size * 0.5
                );
                ctx.bezierCurveTo(
                    -size * 0.7, size * 0.3,
                    -size * 0.7, -size * 0.5,
                    0, -size * 0.5
                );
                ctx.fill();
            },
            
            // 带缺刻的花瓣
            (ctx, size) => {
                ctx.beginPath();
                ctx.moveTo(0, -size);
                ctx.quadraticCurveTo(
                    size * 0.8, -size * 0.5,
                    0, size * 0.2
                );
                ctx.quadraticCurveTo(
                    -size * 0.8, -size * 0.5,
                    0, -size
                );
                ctx.fill();
                
                // 花瓣中心小切口
                ctx.beginPath();
                ctx.arc(0, -size * 0.2, size * 0.15, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
            },
            
            // 长椭圆形花瓣
            (ctx, size) => {
                ctx.beginPath();
                ctx.ellipse(0, 0, size * 0.4, size * 1.2, Math.PI/4, 0, Math.PI * 2);
                ctx.fill();
            },
            
            // 波浪边花瓣
            (ctx, size) => {
                ctx.beginPath();
                const points = 8;
                for (let i = 0; i < points; i++) {
                    const angle = i * (Math.PI * 2) / points;
                    const radius = i % 2 === 0 ? size : size * 0.7;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.fill();
            }
        ];

        class Petal {
            constructor() {
                this.reset();
                this.shapeIndex = Math.floor(Math.random() * petalShapes.length);
                this.life = 0;
                this.maxLife = 500 + Math.random() * 500;
            }

            reset() {
                this.x = Math.random() * petalsCanvas.width;
                this.y = -Math.random() * 200 - 20;
                this.size = Math.random() * 12 + 8;
                this.speedY = Math.random() * 1 + 0.3;
                this.speedX = Math.random() * 0.8 - 0.4;
                this.angle = Math.random() * Math.PI * 2;
                this.rotationSpeed = Math.random() * 0.05 - 0.025;
                this.color = petalColors[Math.floor(Math.random() * petalColors.length)];
                this.opacity = Math.random() * 0.7 + 0.3;
                this.waveAmplitude = Math.random() * 3 + 1;
                this.waveFrequency = Math.random() * 0.02;
                this.waveOffset = Math.random() * Math.PI * 2;
                this.z = Math.random() * 0.5 + 0.5;
                this.wobble = Math.random() * 0.1;
                this.wobbleSpeed = Math.random() * 0.02 + 0.01;
                this.wobbleOffset = Math.random() * Math.PI * 2;
                this.shadow = Math.random() > 0.7;
                this.life = 0;
                this.maxLife = 500 + Math.random() * 500;
            }

            update() {
                this.life++;
                
                // 应用深度效果
                const depthEffect = this.z;
                this.speedY = (Math.random() * 0.5 + 0.3) * depthEffect;
                this.size = (Math.random() * 8 + 6) * depthEffect;
                
                // 基础移动
                this.y += this.speedY;
                
                // 波浪运动
                const wave = Math.sin(this.y * this.waveFrequency + this.waveOffset) * this.waveAmplitude;
                
                // 摆动效果
                const wobble = Math.sin(this.life * this.wobbleSpeed + this.wobbleOffset) * this.wobble;
                
                this.x += this.speedX + wave + wobble;
                this.angle += this.rotationSpeed;
                
                // 生命周期结束重置
                if (this.y > petalsCanvas.height + 50 || this.life > this.maxLife) {
                    this.reset();
                }
                
                // 随机改变透明度
                this.opacity = 0.5 + 0.3 * Math.sin(this.life * 0.05);
            }

            draw() {
                petalsCtx.save();
                petalsCtx.globalAlpha = this.opacity;
                petalsCtx.translate(this.x, this.y);
                petalsCtx.rotate(this.angle);
                
                // 应用深度缩放
                petalsCtx.scale(this.z, this.z);
                
                // 绘制阴影
                if (this.shadow && this.z > 0.7) {
                    petalsCtx.save();
                    petalsCtx.rotate(-this.angle * 0.3);
                    petalsCtx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                    petalsCtx.translate(3, 3);
                    petalShapes[this.shapeIndex](petalsCtx, this.size);
                    petalsCtx.restore();
                }
                
                // 绘制花瓣
                petalsCtx.fillStyle = this.color;
                petalShapes[this.shapeIndex](petalsCtx, this.size);
                
                // 添加纹理
                if (this.size > 10 && this.z > 0.8 && Math.random() > 0.5) {
                    petalsCtx.globalAlpha = this.opacity * 0.3;
                    petalsCtx.strokeStyle = this.lightenColor(this.color, 30);
                    petalsCtx.lineWidth = 0.8;
                    petalsCtx.beginPath();
                    petalsCtx.moveTo(0, -this.size * 0.7);
                    petalsCtx.lineTo(0, this.size * 0.5);
                    petalsCtx.stroke();
                }
                
                petalsCtx.restore();
            }

            // 辅助函数：浅化颜色
            lightenColor(color, percent) {
                let r = parseInt(color.substring(1, 3), 16);
                let g = parseInt(color.substring(3, 5), 16);
                let b = parseInt(color.substring(5, 7), 16);
                
                r = Math.min(255, r + Math.round((255 - r) * percent / 100));
                g = Math.min(255, g + Math.round((255 - g) * percent / 100));
                b = Math.min(255, b + Math.round((255 - b) * percent / 100));
                
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }
        }

        const petals = [];
        const petalCount = 200;

        // 初始化花瓣
        for (let i = 0; i < petalCount; i++) {
            setTimeout(() => {
                petals.push(new Petal());
            }, i * 200);
        }

        // 地面堆积的花瓣
        const groundPetals = [];
        const groundPetalCount = 50;
        
        for (let i = 0; i < groundPetalCount; i++) {
            const p = new Petal();
            p.y = petalsCanvas.height - Math.random() * 100;
            p.x = Math.random() * petalsCanvas.width;
            p.speedY = 0;
            p.speedX = 0;
            p.rotationSpeed = 0;
            p.opacity = 0.6 + Math.random() * 0.3;
            p.life = 999999;
            groundPetals.push(p);
        }

        function animatePetals() {
            petalsCtx.clearRect(0, 0, petalsCanvas.width, petalsCanvas.height);
            
            // 绘制地面花瓣
            for (let i = 0; i < groundPetals.length; i++) {
                groundPetals[i].draw();
            }
            
            // 绘制飘落花瓣
            for (let i = 0; i < petals.length; i++) {
                petals[i].update();
                petals[i].draw();
                
                // 随机添加一些花瓣到地面
                if (petals[i].y > petalsCanvas.height - 30 && Math.random() < 0.01 && groundPetals.length < 150) {
                    const groundPetal = new Petal();
                    groundPetal.y = petalsCanvas.height - Math.random() * 50;
                    groundPetal.x = petals[i].x;
                    groundPetal.speedY = 0;
                    groundPetal.speedX = 0;
                    groundPetal.rotationSpeed = 0;
                    groundPetal.opacity = 0.6 + Math.random() * 0.3;
                    groundPetal.life = 999999;
                    groundPetals.push(groundPetal);
                }
            }

            requestAnimationFrame(animatePetals);
        }

        animatePetals();
        
        // 添加初始地面花瓣
        setTimeout(() => {
            for (let i = 0; i < 30; i++) {
                const p = new Petal();
                p.y = petalsCanvas.height - Math.random() * 100;
                p.x = Math.random() * petalsCanvas.width;
                p.speedY = 0;
                p.speedX = 0;
                p.rotationSpeed = 0;
                p.opacity = 0.6 + Math.random() * 0.3;
                p.life = 999999;
                groundPetals.push(p);
            }
        }, 1000);
    </script>
</body>
</html>
